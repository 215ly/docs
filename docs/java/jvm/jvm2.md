# JVM的相关理论知识补充（二）
## 一、JVM内存模型简介
可以分为两大部分，线程私有区和共享区。参考下图
![JMM内存可见性](..%2F..%2F..%2F.vitepress%2Fpublic%2Fimages%2Fjvm%2F74284d134fdc415aa4f593bd07e503b8.png)
## 线程共享区
- **虚拟机栈**：线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。**栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）**。
- **本地方法栈**：与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同
## 线程私有区
- **方法区**：用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多“static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。
- **程序计数器**：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。
- **堆**：存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的Eden区中，经过GC后进入新生代的S0（survivor from ）区中，然后复制GC进入新生代的S1（survivor to）区中，最后GC将eden和S0区域清空，重新将S1放回S0区域中，保证S0中不存放对象；如果15次GC后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则OutOfMemoryError。
![堆空间结构图](..%2F..%2F..%2F.vitepress%2Fpublic%2Fimages%2Fjvm%2Fa60560a5b6bc4c7fb38ad03cb4d3c38a.png)
## 二、堆和栈的区别
- 栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；
- 堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。
1. 功能不同
栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
2. 共享性不同
栈内存是线程私有的。 堆内存是所有线程共有的。
3. 异常错误不同
如果栈内存或者堆内存不足都会抛出异常。 栈空间不足：java.lang.StackOverFlowError。 堆空间不足：java.lang.OutOfMemoryError。
4. 空间大小
栈的空间大小远远小于堆的。

## 三、类的生命周期
1. **加载**，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
2. **连接**，连接又包含三块内容：验证、准备、初始化。 
 	- 1）**验证**，文件格式、元数据、字节码、符号引用验证； 
 	- 2）**准备**，为类的静态变量分配内存，并将其初始化为默认值； 
 	- 3）**解析**，把类中的符号引用转换为直接引用
3. **初始化**，为类的静态变量赋予正确的初始值
4. **使用**，new出对象程序中使用
5. **卸载**，执行垃圾回收
![类的生命周期](..%2F..%2F..%2F.vitepress%2Fpublic%2Fimages%2Fjvm%2F7e4a591272564c45bcef13f1d65025f4.png)
## 四、如何判断对象可以被回收
- **引用计数法**：：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。**（此方法简单，无法解决对象相互循环引用的问题）**
- **可达性分析（Reachability Analysis）**：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。

## 五、Minor GC与Full GC分别在什么时候发生？
- 新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC
- 当新生代中的对象准备放入老年代中时，如果该对象的大小超出了老年代的一半也会处罚FGC

## 六、JVM性能调优参数？
- 设定堆内存大小
	- -Xmx：堆内存最大限制。
- 设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代
	- -XX:NewSize：新生代大小
	- -XX:NewRatio 新生代和老生代占比
	- -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比
	- 设定垃圾回收器 年轻代用 -XX:+UseParNewGC（Serial的复制算法多线程版本）
	- 年老代用-XX:+UseConcMarkSweepGC（并发标记清除垃圾收集器）