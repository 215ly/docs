# JVM的相关理论知识补充（一）
## 1、内存模型


JVM中的内存模型分为：栈、本地方法栈、程序计数器、堆、方法区。

### 栈
**线程私有**，虚拟机栈描述的是java方法执行的内存模型，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。
> **它的执行速度仅次于程序计数器**
>  **对于栈来说不存在垃圾回收问题**
>  **主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回**。

### 本地方法栈
与栈类似，用来保存执行方法的信息，执行Java方法是使用栈，**执行Native的方法是使用本地方法栈**


### 程序计数器
保存当前线程执行的字节码位置，每一个线程都有独立的计数器，只为执行Java方法服务，执行Native方法时程序计数器为空

### 堆
JVM内存管理中最大的一块，堆被线程共享，目的是存放对象的实例，几乎所有对象实例会被放在堆中；根据对象存活的周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理
> 当堆没有可用空间时会抛出OOM异常
### 方法区
也叫做非堆区,用于存储已经被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.
> JDK1.7的永久代和1.8的元空间都是方法区的一种实现
## 2、类加载机制
### 类加载过程
1. **加载**:文件到内存;**(通过全限定类名,查找此类字节码文件,利用字节码文件创建Class对象)**
2. **验证**:文件格式,元数据,字节码,符号引用;**(用来确保CLass文件符合虚拟机要求且不危害虚拟机安全)**
3. **准备**:准备进行类的内存的分配;**(为static修饰的类变量分配内存,并设置初始值,不包含final修饰的静态变量.因为final变量在编译时分配)**
4. **解析**:将常量池中的符号引用替换为直接引用,直接引用为直接指向目标的指针或者相对偏移量.**(解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行)**
5. **初始化**:主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用时才会初始化.
> 类加载的触发的条件包括:
> **创建类实例时
> 访问类静态方法或者静态变量时
> 使用Class.forName反射类时
> 子类初始化时**


> Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有自定义加载器加载的类可用被卸载

### 类加载机制
#### 双亲委派模式
即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.
> 优点:避免类的重复加载,避免Java的核心API类被篡改

## 3、GC回收
### 分代回收
- 分代回收基于两个事实:
	- 大部分对象很快就不使用了
	- 还有一部分不会立即无用,但也不会持续很长时间
#### 新生代垃圾回收流程
新生代中使用四种垃圾回收算法中的复制算法来进行垃圾回收的，它将新生代又分为了
- Eden (80%)
- survivor from (10%)
- survivor to (10%)

三个区域，并且它们的内存比例为8：1：1
> 比如一个10MB的新生代，会给Eden区分配8MB，两个survivor各分配1MB，但其实供我们使用的内存大小只有9MB，因为其中一个survivor区（survivor to）只是用来协助我们做复制操作的，它不被用来存放对象

**例如:**

在Eden区内存够的情况下，创建的对象会优先选择放到Eden区；

如果在存入对象时，Eden区的内存不够存的，那就会进行一次minor gc垃圾回收，也就是将Eden区中存活的对象复制到survivor from中，然后再清空Eden区；

之后再进来的对象还是会选择放到Eden区，如果Eden区又存放不下了，这时就会将Eden区和survivor from中存活的对象都复制到survivor to中，然后清空Eden区和survivor from，并且将survivor from和survivor to进行位置交换，目的就是为了保证survivor to中不存放对象。

如果这个时候新生代还是放不下这个对象，那该对象就会被放到老年代中。

> **注意，再上述的操作中，对象每移动一次位置，都会给其年龄+1（一个标识），当一个对象的年龄达到15时，就会将该对象纳入老年代中。**
#### 老年代垃圾回收流程
> 复制算法适用于新生代，但是不适用于老年代，因为在老年代中，大部分对象都是存活率比较高的，如果使用复制算法，将会执行多次的复制操作，而且要多分配一个内存空间出来

老年代会采用**标记-清除算法或者标记-整理算法。**

**标记-清除**:从根节点GC ROOT开始往下找，当一个对象脱离了根节点的时候，也就是这个对象没有一条可以到达根节点的路径，我们就将该对象标记为一个垃圾对象,标记完成后执行清除操作.
> 标记-清除需要进行两个操作，标记和清除，效率低；在清除对象之后，还会导致内存空间不连续的问题。

**标记-整理**:将存活的对象收集到一片连续的区域，也就是将它们都靠在一起，然后在清除剩余标记的垃圾对象。

## 4、JMM内存可见性
JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作,由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.
![JMM内存可见性](..%2F..%2F..%2F.vitepress%2Fpublic%2Fimages%2Fjvm%2Fe65538645a3a4f9fb065a52dbeaf30a4.png)

